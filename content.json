{"pages":[{"title":"About","text":"我叫王元秋，这是我 2021 年初自建的博客，我最初写博客是在 2018 年底的时候，也是基于 hexo 搭建然后自己魔改的主题，旧版博客地址现已停更并迁移至 archive.vincent0700.com 挂在 Github Pages 上存档。 目前这个博客是我个人的技术性 Blog，我起了个名字 Horizon，意为地平线。目前这个 Blog 托管在 Cloudflare Pages 上，后面可能考虑在码云上同步一下。 我目前计划将 Blog 分为下面几个板块： 技术积累：主要是结构化的知识整理 读书笔记：日常读书学习的笔记记录 问题解决：记录疑难杂症的解决方案 视野见闻：关注收藏技术圈的新鲜事 工具使用：发现记录身边好用的工具 网络建设：家庭网络及基础设施建设 如果您想留言，目前只支持 Disqus，这意味您必须要熟悉科学上网的相关操作。若有意交换友链，请按照下面格式留言或 Email： 12345[申请添加友链] title: 网站名称 url: 网站地址 desc: 简单介绍 (Optional) avatar: 头像地址 (Optional)","link":"/about/index.html"},{"title":"公共 API 整理","text":"IP相关查询当前公网IPCURL123456789101112131415161718192021222324252627282930313233curl myip.ipip.net# 当前 IP：58.240.94.149 来自于：中国 江苏 南京 联通curl ip-api.com{ &quot;status&quot; : &quot;success&quot;, &quot;continent&quot; : &quot;Asia&quot;, &quot;continentCode&quot;: &quot;AS&quot;, &quot;country&quot; : &quot;China&quot;, &quot;countryCode&quot; : &quot;CN&quot;, &quot;region&quot; : &quot;JS&quot;, &quot;regionName&quot; : &quot;Jiangsu&quot;, &quot;city&quot; : &quot;Nanjing&quot;, &quot;district&quot; : &quot;&quot;, &quot;zip&quot; : &quot;&quot;, &quot;lat&quot; : 32.0617, &quot;lon&quot; : 118.7778, &quot;timezone&quot; : &quot;Asia/Shanghai&quot;, &quot;offset&quot; : 28800, &quot;currency&quot; : &quot;CNY&quot;, &quot;isp&quot; : &quot;CNC Group Jiangsu province network&quot;, &quot;org&quot; : &quot;&quot;, &quot;as&quot; : &quot;AS4837 CHINA UNICOM China169 Backbone&quot;, &quot;asname&quot; : &quot;CHINA169-Backbone&quot;, &quot;mobile&quot; : false, &quot;proxy&quot; : false, &quot;hosting&quot; : false, &quot;query&quot; : &quot;58.240.94.149&quot;}# JSON 版本curl myip.ipip.net/json curl ip-api.com/json 查询指定IP信息CURL12curl ip-api.com/[ip]curl ip-api.com/json/[ip] 大文件下载测速链接 来源 下载链接 Bandwagon 100mb.bin nForce 100mb.bin Leetcode查询「每日一题」POST https://leetcode-cn.com/graphql REQUEST - graphql12345678query questionOfToday { todayRecord { question { questionFrontendId questionTitleSlug } }} RESPONSE123456789101112{ &quot;data&quot;: { &quot;todayRecord&quot;: [ { &quot;question&quot;: { &quot;questionFrontendId&quot;: &quot;1047&quot;, &quot;questionTitleSlug&quot;: &quot;remove-all-adjacent-duplicates-in-string&quot; } } ] }} CURL123curl --location --request POST 'https://leetcode-cn.com/graphql' \\--header 'Content-Type: application/json' \\--data-raw '{ &quot;query&quot;: &quot;query questionOfToday { todayRecord { question { questionFrontendId questionTitleSlug }}}&quot; }' 其他资源 https://github.com/public-apis/public-apis这是一个国外开源的仓库，里面包含了大量国外的公共 API 资源：public-apis toc123456789101112131415161718192021222324252627282930313233343536373839404142434445- Animals- Anime- Anti-Malware- Art &amp; Design- Books- Business- Calendar- Cloud Storage &amp; File Sharing- Continuous Integration- Cryptocurrency- Currency Exchange- Data Validation- Development- Dictionaries- Documents &amp; Productivity- Environment- Events- Finance- Food &amp; Drink- Games &amp; Comics- Geocoding- Government- Health- Jobs- Machine Learning- Music- News- Open Data- Open Source Projects- Patent- Personality- Photography- Science &amp; Math- Security- Shopping- Social- Sports &amp; Fitness- Test Data- Text Analysis- Tracking- Transportation- URL Shorteners- Vehicle- Video- Weather","link":"/apidoc/index.html"}],"posts":[{"title":"用 TS 类型系统实现大数加法","text":"网上有很多实现 TS 加法的奇淫技巧，但是都有很多限制，没法实现太大的数字计算，如何实现一种高效的大数加法呢？ 实现的结果 如何实现String -&gt; Number[]123456789101112131415type DigitRangeMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];type Digit = DigitRangeMap[number];type ToDigit&lt;T extends string&gt; = T extends keyof DigitRangeMap ? DigitRangeMap[T] : never; type ToDigitList&lt;T, R extends any[] = []&gt; = T extends `${infer First}${infer Rest}` ? ToDigitList&lt;Rest, [ToDigit&lt;First&gt;, ...R]&gt; : R;// debugtype test = ToDigitList&lt;&quot;1234&quot;&gt;; // [4, 3, 2, 1] 首先我会把 String 转为 Number 数组，ToDigitList 就是做这个事的，考略到后面方便逐位相加，所以结果处理成倒序。 一位数相加1234567891011121314151617type AdditionMap = [ [0,1,2,3,4,5,6,7,8,9], [1,2,3,4,5,6,7,8,9,10], [2,3,4,5,6,7,8,9,10,11], [3,4,5,6,7,8,9,10,11,12], [4,5,6,7,8,9,10,11,12,13], [5,6,7,8,9,10,11,12,13,14], [6,7,8,9,10,11,12,13,14,15], [7,8,9,10,11,12,13,14,15,16], [8,9,10,11,12,13,14,15,16,17], [9,10,11,12,13,14,15,16,17,18]];type AddOneDigit&lt;A extends Digit, B extends Digit&gt; = AdditionMap[A][B];// debugtype test = AddOneDigit&lt;9,8&gt;; // 17 一位数相加，总共也就只有 100 种情况，为了提高性能，我选择了打表。如果给 A, B 再排一下序，表的体积还能再缩小一半。 处理进位1234567891011type RoundMap = { 10:0; 11:1; 12:2; 13:3; 14:4; 15:5; 16:6; 17:7; 18:8; 19:9};type Carry&lt;T extends number, R extends number[] = []&gt; = T extends keyof RoundMap ? [1, [RoundMap[T], ...R]] : [0, [T, ...R]]; // debugtype test = Carry&lt;15, [3, 2, 1]&gt;; // [1, [5, 3, 2, 1]] Carry 的第一个参数 T 是上一步一位数加法 AddOneDigit 返回的结果，结果范围 0 ~ 19，为什么不是 0 ~ 18 呢？因为还可能有进位 1。因为情况较少，所以还是使用打表计算。第二个参数 R 是前面 N 位计算的结果，类型是 Digit[]。返回的结果是一个 Array，第一个值是进位 0 | 1，第二个值是新增了一位后的结果，类型是 Digit []。 多位数相加123456789101112131415161718192021222324252627282930313233type IncMap = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19];type Shift&lt;T extends any[]&gt; = T extends [infer First, ...infer Rest] ? Rest : never;type AddDigitList&lt; A extends any[], B extends any[], ACC extends [0|1, number[]] = [0, []]&gt; = A['length'] extends 0 ? B['length'] extends 0 // A为空, B为空 ? ACC[0] extends 1 ? AddDigitList&lt;[1], [], [0, ACC[1]]&gt; : ACC[1] // A为空, B非空 : AddDigitList&lt;A, Shift&lt;B&gt;, Carry&lt;AddOneDigit&lt;B[0], ACC[0]&gt;, ACC[1]&gt;&gt; : B['length'] extends 0 // A非空, B为空 ? AddDigitList&lt;Shift&lt;A&gt;, B, Carry&lt;AddOneDigit&lt;A[0], ACC[0]&gt;, ACC[1]&gt;&gt; // A非空, B非空 : AddDigitList&lt; Shift&lt;A&gt;, Shift&lt;B&gt;, Carry&lt; ACC[0] extends 0 ? AddOneDigit&lt;A[0], B[0]&gt; : IncMap[AddOneDigit&lt;A[0], B[0]&gt;], ACC[1] &gt; &gt;;// debugtype test = AddDigitList&lt;[2,5], [1,5]&gt;; // [1,0,3] 重点来了，AddDigitList 接受两个 Digit[] 类型，返回同样是 Digit[] 类型加法的结果。我用参数 ACC 承载上一步 Carry 的返回作为累加的结果，我用伪代码描述一下这部分逻辑： 1234567891011121314151617181920212223242526function fn(a: number[], b: number[], acc = [0, []]) { if (a.length === 0) { if (b.length === 0) { return acc[0] == 1 ? fn([1], [], [0, acc[1]]) : acc[1]; } else { return fn( a, b.slice(1), carry(add(b[0], acc[0]), acc[0]) ) } } else { if (b.length === 0) { return fn( a.slice(1), b, carry(add(a[0], acc[0]), acc[0]) ) } else { return fn( a.slice(1), b.slice(1), carry(add(add(a[0], b[0]), acc[0]), acc[0]) ) } }} Number[] -&gt; String1234567891011121314151617type StrDigitRangeMap = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];type DigitListToString&lt;T extends any[], R extends string = ''&gt; = T extends [infer First, ...infer Rest] ? DigitListToString&lt; Rest, `${R}${First extends number ? StrDigitRangeMap[First] : 'n' }` &gt; : R; type Add&lt;A extends string, B extends string&gt; = DigitListToString&lt;AddDigitList&lt;ToDigitList&lt;A&gt;, ToDigitList&lt;B&gt;&gt;&gt;; // debugtype result = Add&lt; &quot;1248859103109591728912488591031095917289&quot;, &quot;32481239839485789343248123983948578934&quot;&gt;; 最后的处理，将 Digit[] 转为 String，看到结果顺滑的显示在我的 VSCode 提示框中，我不禁 完整代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071type DigitRangeMap = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];type StrDigitRangeMap = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];type RoundMap = { 10:0; 11:1; 12:2; 13:3; 14:4; 15:5; 16:6; 17:7; 18:8; 19:9 };type AdditionMap = [ [0,1,2,3,4,5,6,7,8,9], [1,2,3,4,5,6,7,8,9,10], [2,3,4,5,6,7,8,9,10,11], [3,4,5,6,7,8,9,10,11,12], [4,5,6,7,8,9,10,11,12,13], [5,6,7,8,9,10,11,12,13,14], [6,7,8,9,10,11,12,13,14,15], [7,8,9,10,11,12,13,14,15,16], [8,9,10,11,12,13,14,15,16,17], [9,10,11,12,13,14,15,16,17,18]];type IncMap = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19];type Digit = DigitRangeMap[number];type ToDigit&lt;T extends string&gt; = T extends keyof DigitRangeMap ? DigitRangeMap[T] : never;type ToDigitList&lt;T, R extends any[] = []&gt; = T extends `${infer First}${infer Rest}` ? ToDigitList&lt;Rest, [ToDigit&lt;First&gt;, ...R]&gt; : R;type Shift&lt;T extends any[]&gt; = T extends [infer First, ...infer Rest] ? Rest : never;type Carry&lt;T extends number, R extends number[] = []&gt; = T extends keyof RoundMap ? [1, [RoundMap[T], ...R]] : [0, [T, ...R]];type AddOneDigit&lt;A extends Digit, B extends Digit&gt; = AdditionMap[A][B];type AddDigitList&lt; A extends any[], B extends any[], ACC extends [0|1, number[]] = [0, []]&gt; = A['length'] extends 0 ? B['length'] extends 0 ? ACC[0] extends 1 ? AddDigitList&lt;[1], [], [0, ACC[1]]&gt; : ACC[1] : AddDigitList&lt;A, Shift&lt;B&gt;, Carry&lt;AddOneDigit&lt;B[0], ACC[0]&gt;, ACC[1]&gt;&gt; : B['length'] extends 0 ? AddDigitList&lt;Shift&lt;A&gt;, B, Carry&lt;AddOneDigit&lt;A[0], ACC[0]&gt;, ACC[1]&gt;&gt; : AddDigitList&lt; Shift&lt;A&gt;, Shift&lt;B&gt;, Carry&lt; ACC[0] extends 0 ? AddOneDigit&lt;A[0], B[0]&gt; : IncMap[AddOneDigit&lt;A[0], B[0]&gt;], ACC[1] &gt; &gt;;type DigitListToString&lt;T extends any[], R extends string = ''&gt; = T extends [infer First, ...infer Rest] ? DigitListToString&lt; Rest, `${R}${First extends number ? StrDigitRangeMap[First] : 'n' }` &gt; : R; type Add&lt;A extends string, B extends string&gt; = DigitListToString&lt;AddDigitList&lt;ToDigitList&lt;A&gt;, ToDigitList&lt;B&gt;&gt;&gt;; 本文已转载到 掘金 和 知乎 字节前端账号。","link":"/2021/09/11/20210911_%E7%94%A8TS%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%95%B0%E5%8A%A0%E6%B3%95/"},{"title":"柏林噪声算法解析","text":"柏林噪声（Perlin Noise）算法是 Ken Perlin 发明的一种自然噪声生成算法，并在图形学领域广泛使用。例如模拟火焰、云彩的纹理、生成随机地形图等。 案例分析封面图是我利用柏林噪声实现的地图生成器。以下是绘制逻辑的主要代码， 12345678910111213141516for (let x = 0; x &lt; xMax; x++) { for (let y = 0; y &lt; yMax; y++) { const v = noise(x, y); if (v &gt; 0.8) { drawBlock(x, y, '#eeeeee') // 海洋 } else if (v &gt; 0.6) { drawBlock(x, y, '#168B67') // 沙地 } else if (v &gt; 0.4) { drawBlock(x, y, '#88F116') // 平原 } else if (v &gt; 0.3) { drawBlock(x, y, '#FFEB79') // 高原 } else { drawBlock(x, y, '#2EDFFF') // 雪山 } }} 首先我把屏幕区域按照 BlockSize 分成 [xMax, yMax] 数量的区块，通过柏林噪声生成一张二维连续的高度图，noise(x, y) 取到高度值，根据高度值将 BlockType 划分为：海洋、沙地、平原、高原、雪山，然后给区块着色。 算法分析由以上案例可知，当入参 (x, y) 连续，noise(x, y) 的值也是连续的，那么 noise 函数是如何实现的呢？柏林噪声是一种 基于晶格的 (Lattice based) 梯度噪声算法(Gradient Noise)。下面是算法解析： 划分晶格我们暂且以长度为 1 的晶格划分整个二维空间，如下图，当我们的入参 (x, y) 为 (3.7, 2.7) 时，坐标点将落入右侧的正方形晶格中。 梯度向量然后我们分别以正方形的 4 个晶格为原点，各自生成一个 伪随机 的梯度向量，如下面左图中的 G1、G2、G3、G4。顶点的梯度向量代表 该顶点对于晶格内点的 影响 。 伪随机的含义是当 seed 一定时，梯度向量也相同。 打个简单的比方，晶格空间内原本分布着均匀的像素点，这时候四个顶点分别有 4 个沿着向量方向的力进行拉扯，沿着力的方向像素点越密集，就像右上这样，越接近黄色的区域，空间分布越密集，影响值越大。 距离向量怎么去量化这种 影响 呢？我们引入距离向量。如下图所示，对于空间内的点 P(x, y)，四个顶点分别生成了指向它的距离向量 D1、D2、D3、D4。 顶点对该点的影响值即为梯度向量 G 与距离向量 D 的点积。由此我们得到： $$\\begin{cases}u_1 = \\overrightarrow {G_1} \\centerdot \\overrightarrow {D_1} \\\\u_2 = \\overrightarrow {G_2} \\centerdot \\overrightarrow {D_2} \\\\u_3 = \\overrightarrow {G_3} \\centerdot \\overrightarrow {D_3} \\\\u_4 = \\overrightarrow {G_4} \\centerdot \\overrightarrow {D_4}\\end{cases}$$ 归一化处理我们现在得到了 4 个标量 u1、u2、u3、u4，且都随变量 P(x, y) 连续变化，现在我们需要将他们合并成一个值 t，使得 t 同样随着 P(x, y) 连续变化。 $$t_1 = lerp(u_1, u_2, x)$$ $$t_2 = lerp(u_3, u_4, x)$$ $$t = lerp(t_1, t_2, y)$$ 插值函数上面公式中提到的 lerp 函数就是插值函数，其实在我们日常编码中经常会使用到，例如 css 的 transition-timing-function 的属性 linear、ease、ease-in、ease-out、ease-in-out 等等都是插值函数。他们的函数图像如下： 拿最简单的线性插值函数为例，实现代码如下： 1const lerp = (min, max, t) =&gt; min * (1 - t) + max * t; 至此，我们根据传入点 (x, y) 通过算法 Perlin(x, y) 得到了一个归一化的结果 t，并且结果 t 会随着 (x, y) 的变化而连续变化，这就是柏林噪声算法。具体实现代码因为篇幅原因我就不贴出来了，感兴趣的同学可以根据上述分析自己实现一下。","link":"/2021/10/19/20211019_%E6%9F%8F%E6%9E%97%E5%99%AA%E5%A3%B0%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90/"},{"title":"glTF 2.0 格式详解","text":"glTF 全称 GL Transmission Format，是由现有 OpenGL 的维护组织 Khronos 推出的一种 3D 数据传输格式，常用于 WebGL 和 OpenGL。 格式简介格式特性 紧凑的文件大小。glTF JSON 文件本身是明文，紧凑且解析速度快，其他大型数据（如几何和动画）都存储在二进制文件中。 快速加载。glTF 的数据结构非常接近 GPU API，减少解析时间。 运行时独立性。glTF 不依赖任何 3D 引擎，不指定渲染和动画以外的运行时行为。 完整的 3D 场景表示。对于许多应用程序来说，从建模包中导出单个对象是不够的。通常，作者希望将整个场景（包括节点、变换、变换层次、网格、材质、相机和动画）加载到他们的应用程序中。glTF 努力保留所有这些信息以供下游应用程序使用。 可扩展性。虽然最初的基础规范支持丰富的功能集，但仍有许多增长和改进的机会。glTF 定义了一种机制，允许添加通用扩展。 与其他 3D 格式对比 mesh 材质 骨骼 动画 场景信息 STL ✔ ✖ ✖ ✖ ✖ OBJ ✔ ✔ ✖ ✖ ✖ FBX ✔ ✔ ✔ ✔ ✔ glTF ✔ ✔ ✔ ✔ ✔ 1.0 与 2.0 版本的区别最主要的改动是 1.0 使用 glsl 去描述材质，而 2.0 使用了更加通用的 PBR 材质。 格式解析glTF 由 JSON 文件、bin 文件和其他外部数据（如图片等）组成，JSON 文件的根节点属性见下图： 数据类型 描述 accessors accessor [1-*] An array of accessors. animations animation [1-*] An array of keyframe animations. asset object Metadata about the glTF asset. buffers buffer [1-*] An array of buffers. bufferViews bufferView [1-*] An array of bufferViews. cameras camera [1-*] An array of cameras. images image [1-*] An array of images. materials material [1-*] An array of materials. meshes mesh [1-*] An array of meshes. nodes node [1-*] An array of nodes. samplers sampler [1-*] An array of samplers. scene integer The index of the default scene. scenes scene [1-*] An array of scenes. skins skin [1-*] An array of skins. textures texture [1-*] An array of textures. extensions object Dictionary object with extension-specific objects. extras any Application-specific data. asset顶级必须包含 asset 属性，其中必须包含 version 指明 glTF 的版本，还可包含如下的其他附加信息。 12345678910&quot;asset&quot;: { &quot;extras&quot;: { &quot;author&quot;: &quot;EdwinRC (https://sketchfab.com/Edwin3D)&quot;, &quot;license&quot;: &quot;CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)&quot;, &quot;source&quot;: &quot;https://sketchfab.com/3d-models/low-poly-winter-scene-2ffe1ed449414cc184078dd1e2882284&quot;, &quot;title&quot;: &quot;Low Poly Winter Scene&quot; }, &quot;generator&quot;: &quot;Sketchfab-4.86.2&quot;, &quot;version&quot;: &quot;2.0&quot;} buffers &amp; bufferViews二进制数据和索引视图，如下，通过 uri 指明 buffer[0] -&gt; ./scene.bin，然后再 bufferView 中通过 offset 和 length 去索引 buffer 数据。 12345678910111213141516&quot;buffers&quot;: [ { &quot;byteLength&quot;: 8570184, &quot;uri&quot;: &quot;scene.bin&quot; }],&quot;bufferViews&quot;: [ { &quot;buffer&quot;: 0, &quot;byteLength&quot;: 792612, &quot;byteOffset&quot;: 0, &quot;name&quot;: &quot;floatBufferViews&quot;, &quot;target&quot;: 34963 }, // ...] scene &amp; scenesscene 表明默认加载的场景，下面的结构表示默认会加载定义在 scenes[0] 的场景。场景是由 nodes 节点构成，节点是树状结构，如下则会加载根节点为 nodes[0] 的节点。 1234567&quot;scene&quot;: 0,&quot;scenes&quot;: [ { &quot;name&quot;: &quot;OSG_Scene&quot;, &quot;nodes&quot;: [0] }] nodes节点和层次结构。节点类似图层的概念，可以包含 mesh 或应用平移 (translation)、旋转 (rotation)、缩放 (scale) 或任意矩阵变换 (matrix)，如下图，nodes[0] 包含子节点 nodes[1]，并且应用了旋转变换，这里旋转用四元数表示。而 nodes[1] 包含了 meshes[0] 的网格数据。 12345678910111213141516171819&quot;nodes&quot;: [ { &quot;children&quot;: [ 1 ], &quot;name&quot;: &quot;RootNode (gltf orientation matrix)&quot;, &quot;rotation&quot;: [ -0.70710678118654746, -0, -0, 0.70710678118654757 ] }, { &quot;mesh&quot;: 0, &quot;name&quot;: &quot;Cylinder.008_0&quot; }, // ...] meshes网格数据是模型最重要的部分，如下所示，meshes[0] 是一个 Cylinder.008_0 的圆柱体网格。 attributes 的数据会直接传入 vertex shader，它们的含义如下： POSITION 顶点坐标 NORMAL 法向量 TANGENT 切向量 COLOR_0 顶点颜色 TEXCOORD_0 贴图UV，可以看出 glTF 支持多组 UV 它们的值是 accessor 的索引，最终会取到 bufferView -&gt; buffer 中的数据。例如 POSITION 应该是 XYZ 坐标的数组，TEXCOORD_0 应该 UV 坐标的数组。 mode 和 indices 涉及到图元装配，mode 是枚举类型，与 WebGL 中定义的一致： 类型 取值 POINTS 0 LINES 1 LINE_LOOP 2 LINE_STRIP 3 TRIANGLES 4 TRIANGLE_STRIP 5 TRIANGLE_FAN 6 所以这里 indices 为三角形 mesh 顶点的索引数组，数据也是通过 accessor 索引。material 是材质的索引，存放在 materials[0]。 1234567891011121314151617181920&quot;meshes&quot;: [ { &quot;name&quot;: &quot;Cylinder.008_0&quot;, &quot;primitives&quot;: [ { &quot;attributes&quot;: { &quot;COLOR_0&quot;: 3, &quot;NORMAL&quot;: 1, &quot;POSITION&quot;: 0, &quot;TANGENT&quot;: 2, &quot;TEXCOORD_0&quot;: 4 }, &quot;indices&quot;: 5, &quot;material&quot;: 0, &quot;mode&quot;: 4 } ] }, // ...] accessors访问器。是 glTF 特有的访问数据的结构，它关联了 bufferView 声明的数据切片，指明了数据类型，同时也附带了额外信息，如 min、max、count 等。 1234567891011&quot;accessors&quot;: [ { &quot;bufferView&quot;: 2, &quot;componentType&quot;: 5126, &quot;count&quot;: 25327, &quot;max&quot;: [15.562509536743164, -45.877700805664062, 30.865560531616211], &quot;min&quot;: [-31.794599533081055, -90.910537719726562, -38.811481475830078], &quot;type&quot;: &quot;VEC3&quot; } // ...] type 类型 含义 元素数量 SCALAR 标量 1 VEC2 元向量，常用于描述 uv 2 VEC3 3元向量，常用于描述 xyz 坐标或 rgb 颜色 3 VEC4 4元向量，常用于描述四元数或 rgba 颜色 4 MAT2 2阶矩阵 4 MAT3 3阶矩阵 9 MAT4 4阶矩阵 16 materials材质。glTF 2.0 支持了 PBR 材质，PBR (Physically Based Rendering) 的含义是基于物理正确的方式来计算灯光与材质，也就是说 PBR 材质的渲染基于物理引擎而非渲染器。目前 PBR 材质已经被各种图形引擎和建模软件所支持，是一种通用的材质规范，因此也非常符合 glTF 的理念。具体 PBR 相关概念可以参考这篇文章 Physically Based Rendering and Lighting 下面的例子定义了一个 PBR 材质，首先 doubleSided 表明了它是双面渲染的，然后 baseColorFactor 定义了它的基本颜色是 rgba(1, 1, 1, 1) 的白色，baseColorTexture 定义了贴图的索引和 uv，metallicFactor 描述了金属性，roughnessFactor 描述了粗糙程度。 12345678910111213141516171819&quot;materials&quot;: [ { &quot;doubleSided&quot;: true, &quot;name&quot;: &quot;Main&quot;, &quot;pbrMetallicRoughness&quot;: { &quot;baseColorFactor&quot;: [ 1, 1, 1, 1 ], &quot;baseColorTexture&quot;: { &quot;index&quot;: 0, &quot;texCoord&quot;: 0 }, &quot;metallicFactor&quot;: 0, &quot;roughnessFactor&quot;: 0.6 } } textures &amp; images贴图。texture 对象的 source 和 sampler 关联了图片(images) 和采样器(samplers) 的索引。images 通过 uri 关联外部图片文件。 1234567891011&quot;textures&quot;: [ { &quot;sampler&quot;: 0, &quot;source&quot;: 0 }],&quot;images&quot;: [ { &quot;uri&quot;: &quot;textures/Main_baseColor.png&quot; }] samplers采样器。描述了纹理映射的方式。其参数 magFilter、minFilter、wrapS、wrapT 都是枚举类型。 12345678&quot;samplers&quot;: [ { &quot;magFilter&quot;: 9729, &quot;minFilter&quot;: 9987, &quot;wrapS&quot;: 10497, &quot;wrapT&quot;: 10497 }] magFilter拉伸纹理，表示三角面大而纹理小的情况，取值如下 类型 取值 含义 NEAREST 9728 取临近点的颜色，对应 GL_NEAREST LINEAR 9729 线性插值，对应 GL_LINEAR minFilter压缩纹理，表示三角面小而纹理大的情况，增加 mipmap 的情况，概念和上面类似，取值如下 类型 取值 NEAREST 9728 LINEAR 9729 NEAREST_MIPMAP_NEAREST 9984 LINEAR_MIPMAP_NEAREST 9985 NEAREST_MIPMAP_LINEA 9986 LINEAR_MIPMAP_LINEAR 9987 wrapS横轴 wrap mode 类型 取值 示例 CLAMP_TO_EDGE 33071 MIRRORED_REPEAT 33648 REPEAT 10497 wrapT纵轴 wrap mode，取值同 wrapS 最后总结最后附一张官方给出的 glTF 格式的属性节点关系图，便于理清各个节点的映射关系，如果还有细节的地方不明白，可以参考 glTF 2.0 官方文档","link":"/2021/09/23/20210922_glTF2.0%E6%A0%BC%E5%BC%8F%E8%AF%A6%E8%A7%A3/"},{"title":"家庭网络改造，软路由 R4S 踩坑","text":"NanoPi R4S 是友善电子团队推出的一款 Arm 架构的软路由，这是 R2S 的升级版。之前用家里废弃的主机刷过 OpenWrt，但是主机同时需要常年开启，体积大没办法塞进弱电箱，还有功耗、噪音也成问题。这段时间家里准备装修，所以正好借此重新设计一下家里的弱电和网络结构，这款小巧的软路由正好符合我的需求。 名词解释下面科普一些网络方面的知识，仅供大家参考，大佬可以直接跳过。 [ 软路由 ] 是指利用台式机或服务器配合软件形成路由解决方案，主要靠软件的设置，达成路由器的功能；而硬路由则是以特有的硬设备，包括处理器、电源供应、嵌入式软件，提供设定的路由器功能。 所以说，硬路由是专门为路由设计的嵌入式设备，考虑到成本、性价比、功耗等因素一般不会堆太多料，我目前用的 R7000 1GHz 双核、256MB RAM 在家用路由器里已经算非常不错了，若仅仅是路由功能，那么硬路由的性能绰绰有余所以我推荐如果不具备以下条件的朋友请勿购买软路由： 了解基础的网络知识 有良好的心理素质，经得起折腾 \b确实有需求在路由器里跑一些程序 [ OpenWrt ]OpenWrt 是一个针对嵌入式设备而开发的一个 Linux 操作系统，目的是为了让用户更方便的操作固件而实现各种定制化的效果，现已广泛应用户软路由、嵌入式设备中。官方中文 Wiki [ 五类线 vs 超五类线 vs 六类线 ]五类线（CAT5）， 超五类（CAT5e)，六类线（CAT6）的网线最主要是在传输速率上面的区别。 种类 传输速率 如何区分 CAT5 100 Mbps 外皮 CAT5 标识 CAT5e 100 - 1000 Mbps 外皮 CAT5e 标识 CAT6 1000 Mbps 外皮 CAT6 标识，内部增加了十字骨架，直径较粗 网络拓扑结构设计我家之前只有一台华硕 R7000 作为主路由 + AP，现在需要把软路由 R4S 作为主路由，R7000 仅当作 AP 使用，关闭路由功能。网络拓扑结构如下图所示： R4S 安装部署R4S 分 1G 和 4G RAM 两个版本，我买的是 4G 的，但实测下来应该 1G 版就绰绰有余了。然后外壳可选亚克力塑料外壳带风扇或者铝合金外壳被动散热，看知乎上大佬推荐的铝合金外壳就买了。另外我还买了一张 16G 的 tf 卡，因为 R4S 是不带内部存储的，系统是要自己刷进 tf 卡，所以这一项是必须的。当然某宝上也有全套懒人套餐。 刷机 买来第一件事就是刷机了，友善官方定制了一套 OpenWrt 的系统，但是官方系统是不带插件的，所以我推荐安装第三方固件。官方固件链接第三方编译固件第三方固件有很多版本，我推荐使用 ext4 版本的，文件名 *-ext4-sysupgrade.img.gz。 安装刷机工具 Etcher，macOS、Windows、Linux 都是支持的。Etcher 下载链接 然后把 tf 卡装进读卡器里，选择镜像就能卡刷了。 管理面板默认用户名/密码是root/password，ssh 默认开着的。 根路径扩容卡刷完默认是 4G 的磁盘，剩余 12G 的分区还没有创建，所以我们需要扩容一下，可以挂载到其他路径，不过我还是推荐直接挂载到根路径。具体操作步骤如下： 选择 [系统] &gt; [磁盘管理] 可以看到我们的 tf 卡磁盘。 选择修改， 新增分区，容量为剩余空间。 ssh 登录，创建挂载点 /data，mkdir -p /data。 继续在管理面板 [磁盘管理] 中设置挂载点为 /data。 拷贝原来 /overlay 分区的内容，cp -f -a /overlay/. /data。 选择 [系统] &gt; [挂载点] 找到我们新增的挂载点 /data 的分区，选择修改。 启用挂载点，设置为外部 /overlay 使用，如下图所示： 重启 R4S，再次查看磁盘分区，发现根路径挂载分区的容量已修改。 配置动态域名解析如果你想让你的路由器能对外服务，那么你还需要绑定域名，家用宽带默认只会给你 NAT 转换后的 IP，不过你打电话给当地运营商的客服说要独立 IP，对方应该是会给你开的，不过常用的 80、443、22 等端口一般是封死的。 当地运营商给你的肯定是动态 IP，只要你重新拨号 IP 就会变更，这时候就的开启 DDns 已同步远端的 Dns 服务商重新解析。这里我推荐使用 dnspod 免费 3 个域名解析，同时还支持动态解析。具体操作步骤如下： 选择头像 &gt; [密钥管理]，添加密钥。 进入 OpenWrt 管理面板，选择 [服务] &gt; [动态DNS]，输入刚才添加的密钥即可。 保存重启，看看 dnspod 那边的解析有没有修改。 其他服务配置这个第三方固件里还包含了其他很多插件，可自行启用： 代理服务：各种代理协议、OpenClash 容器服务：Docker VPN服务：PPTP、IPSec、OpenVPN、ZeroTier 等 内网穿透：frps、nps 网络服务：迅雷快鸟、UU加速器、Aria2 等 网络共享：WebDav、SMB、SFTP 等 无线接入点R4S 是不带无线接入的，所以我们还需要一个 AP，刚好我家以前的硬路由 R7000 派上了用场，我把路由模式改成了 AP 模式，这样硬路由的压力会小很多，而且和主路由在同一个网段，端口映射会方便一些。 弱电改造家里之前铺设的都是五类线，装修\b后全部改成六类线，推荐家里用大号带电源的弱电箱，可以放一些服务设备，很实用。预计家里装修今年8月份完工，届时会再分享一波。","link":"/2021/03/08/20210305_%E8%BD%AF%E8%B7%AF%E7%94%B1R4S%E8%B8%A9%E5%9D%91/"},{"title":"使用 Test262 的正确姿势","text":"Test262 是一套由 TC39 制定的标准化 ECMAScript 规范测试集。Test262 促成我们在不同的 JavaScript 运行环境中同样的 JavaScript 代码都能获得预期的同样结果，也将 JavaScript 语言的语义细节都使用避免歧义的标准文本在规范中详细地记录了下来，让我们更加容易理解 JavaScript 的行为。如果你不了觉 TC39 与 ECMAScript 的相关信息，可以看我之前写过的一篇文章 《TC39 与 ECMAScript 提案》。 基本用法12345# 拉取代码$ git clone https://github.com/tc39/test262.git# 安装命令行工具$ npm i -g test262-harness 所有的测试集都在 /test 目录，命令行只需要指定 JS 引擎和测试路径即可，比如现在我想测试一下 node 对内置对象 BigInt 的支持情况，我可以在 test262 项目下执行： 12345678$ test262-harness \\--hostType=node \\--hostPath=`which node` \\test/built-ins/BigInt/**/*.js'''Ran 146 tests146 passed0 failed 测试 JS 引擎下面是支持的 hostType： Host Name Type Supported Platforms ch¹ ChakraCore CLI Any d8¹ V8 CLI Any engine262 Engine262 CLI Any graaljs GraalJS CLI Any jsshell¹ SpiderMonkey CLI Any jsc¹ JavaScriptCore CLI Mac² nashorn Nashorn CLI Any node Node.js CLI Any qjs4 QuickJS CLI Any xs Moddable XS CLI Any chrome Google Chrome Browser Any edge Microsoft Edge Browser Windows firefox Mozilla Firefox Browser Any safari Apple Safari Browser Mac 详情见 eshost 测试 Polyfill例如你要实现一个 Promise 的 Polyfill： 1234# polyfill-promise.jsclass Promise { // ...} 然后通过 prelude 参数调用： 12345$ test262-harness \\--hostType=node \\--hostPath=`which node` \\--prelude=/path/to/polyfill-promise.js \\test/built-ins/Promise/**/*.js","link":"/2021/03/11/20210311_%E4%BD%BF%E7%94%A8Test262%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"},{"title":"Three.js 骨骼动画原理","text":"模型动画分两种，顶点动画和骨骼动画，上图行走的史蒂夫是我用 three.js 写的一个骨骼动画的 Demo 顶点动画 (Vertex Animation)相对于骨骼动画，顶点动画的概念可能更好理解一些。我们对模型的网格数据逐帧、逐顶点进行矩阵变换（平移、旋转、缩放），记录下每帧的变换操作；或是利用插值函数记录下关键帧，这就是顶点动画了。理论上顶点动画完全可以实现任意的模型动画，然而这是一项数据密集型的技术，数据太过冗余，实际生产中很少用到。 骨骼动画 (Skeleton Animation)骨骼拉伸带动肌肉，肌肉再带动皮肤。我们只需记录骨骼的位置就能得出皮肤网格的顶点位置。 骨骼 Bone骨骼有3个基础元素（见右上图）： 头部 Root 主体 Body 尾部 Tip 蒙皮 Skinned蒙皮就是把骨骼和模型结合起来的过程，蒙皮网格叫做 Skinned Mesh。在一些建模软件中，支持一键蒙皮（根据网格顶点到骨骼的距离自动赋权重）。 权重 Weight蒙皮网格中还包含了 顶点受哪些骨骼影响 以及这些 骨骼影响该顶点的权重。听起来有点绕，用公式表示蒙皮网格顶点的坐标大概像这样：$$P_i = \\sum_j W_j \\cdot ( \\mathbf{M_j} \\times \\vec{V_i} )$$其中 i 是网格顶点的下标，j 表示骨骼的下标，$V_i$ 表示网格的模型坐标，$P_i$ 表示变换后网格的世界坐标，$W_j$ 表示第 j 个骨骼对网格顶点的影响，$\\mathbf M_j$ 是一个 4x4 矩阵，表示骨骼变换本身（平移、旋转、缩放）。 three.js 对骨骼动画的实现我们以最常用的 MeshStandardMaterial 材质为例，梳理一下 three.js 着色部分的源码 着色器入口 ShaderLib.js首先找到材质 shader 的入口 src/renderers/shaders/ShaderLib.js ./src/renderers/shaders/ShaderLib.js123456789101112131415161718192021222324252627282930const ShaderLib = { basic: { /* ... */ }, lambert: { /* ... */ }, phong: { /* ... */ }, standard: { uniforms: mergeUniforms([ UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, { emissive: { value: new Color( 0x000000 ) }, roughness: { value: 1.0 }, metalness: { value: 0.0 }, envMapIntensity: { value: 1 } } ]), vertexShader: ShaderChunk.meshphysical_vert, fragmentShader: ShaderChunk.meshphysical_frag }, // ...} 传了一堆 uniforms 进来，以及着色器的入口，骨骼主要是在顶点着色阶段作用。 理解源码我们进入 meshphysical_vert (meshphysical.glsl) 看看，我省略了大部分无关的引入。&lt;完整源码&gt; ./src/renderers/shaders/ShaderLib/meshphysical.glsl.js123456789101112131415/* ~~ #include ... ~~ */#include &lt;skinning_pars_vertex&gt;void main() { /* ~~ #include ... ~~ */ #include &lt;skinbase_vertex&gt; #include &lt;begin_vertex&gt; #include &lt;skinbase_vertex&gt; #include &lt;skinning_vertex&gt; #include &lt;project_vertex&gt; /* ~~ #include ... ~~ */} 如果你读过 three.js 着色器源码的话就能发现 three 的着色器充斥着大量的 #include，非常不方便阅读，我简单整理代码，将 #include 的代码合并到一个文件中： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/* ~~ #include &lt;skinning_pars_vertex&gt; ~~ */#ifdef USE_SKINNING uniform mat4 bindMatrix; uniform mat4 bindMatrixInverse; #ifdef BONE_TEXTURE uniform highp sampler2D boneTexture; uniform int boneTextureSize; mat4 getBoneMatrix( const in float i ) { float j = i * 4.0; float x = mod( j, float( boneTextureSize ) ); float y = floor( j / float( boneTextureSize ) ); float dx = 1.0 / float( boneTextureSize ); float dy = 1.0 / float( boneTextureSize ); y = dy * ( y + 0.5 ); vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) ); vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) ); vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) ); vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) ); mat4 bone = mat4( v1, v2, v3, v4 ); return bone; } #else uniform mat4 boneMatrices[ MAX_BONES ]; // 获取骨骼变换矩阵 mat4 getBoneMatrix( const in float i ) { mat4 bone = boneMatrices[ int(i) ]; return bone; } #endif#endifvoid main() { /* ~~ #include &lt;begin_vertex&gt; ~~ */ // 用模型空间坐标初始化 transformed 变量 vec3 transformed = vec3(position); /* ~~ #include &lt;skinbase_vertex&gt; ~~ */ #ifdef USE_SKINNING mat4 boneMatX = getBoneMatrix( skinIndex.x ); mat4 boneMatY = getBoneMatrix( skinIndex.y ); mat4 boneMatZ = getBoneMatrix( skinIndex.z ); mat4 boneMatW = getBoneMatrix( skinIndex.w ); #endif /* ~~ #include &lt;skinning_vertex&gt; ~~ */ #ifdef USE_SKINNING // 被控顶点通过 bindMatrix 变换到骨骼空间坐标 vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 ); vec4 skinned = vec4( 0.0 ); // 应用骨骼变换，一个顶点最多支持被 4 个骨骼控制 skinned += boneMatX * skinVertex * skinWeight.x; skinned += boneMatY * skinVertex * skinWeight.y; skinned += boneMatZ * skinVertex * skinWeight.z; skinned += boneMatW * skinVertex * skinWeight.w; // 再通过 bindMatrix 的逆矩阵变换回模型空间坐标 transformed = ( bindMatrixInverse * skinned ).xyz; #endif /* ~~ #include &lt;project_vertex&gt; ~~ */ // 模型经过骨骼变换 vec4 mvPosition = vec4( transformed, 1.0 ); #ifdef USE_INSTANCING /** * 这是 webgl2 实例化绘制的一个特性，可以缓存上次绘制的 uniforms, * 可以提高重复绘制相同物体的性能，可以先忽略 * @see https://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-instanced-drawing.html */ mvPosition = instanceMatrix * mvPosition; #endif // 乘以模型矩阵得到世界坐标 mvPosition = modelViewMatrix * mvPosition; // 乘以投影矩阵得到屏幕坐标，可以说 VertexShader 的目的主要就是得到 gl_Position gl_Position = projectionMatrix * mvPosition;} 总结最后总结下 three.js 顶点着色器的主要逻辑 transformed = position (模型空间坐标) skinVertex = bindMatrix * transformed (骨骼空间坐标) skinned = boneMat * skinVertex * skinWeight (应用骨骼变换) transformed = bindMatrixInverse * skinned (变回模型空间) gl_Position = MVP * transformed (得到屏幕坐标)","link":"/2021/12/15/20211215_ThreeJs%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E5%8E%9F%E7%90%86/"},{"title":"Vue 源码阅读","text":"最近公司项目逐渐从 Vue2 迁到 Vue3，我也趁机补一波干货，下面的一些篇幅将会记录我阅读 Vue3 源码的过程和一些思考。 环境搭建首先下载源码，Vue3 尤大大切了一个新的仓库去写，仓库名是 vue-next 1git clone https://github.com/vuejs/vue-next.git 首先看了一下项目结构，很明显是一个 Monorepo 组织的项目： 12345678910111213├── packages│ ├── compiler-core // 编译器核心│ ├── compiler-dom // 编译DOM│ ├── compiler-sfc // 编译Vue单文件│ ├── compiler-ssr // 编译服务端渲染│ ├── reactivity // 响应式代码│ ├── runtime-core // 运行时核心│ ├── runtime-dom // 运行时DOM│ ├── runtime-test // 内部测试代码│ ├── server-renderer // 服务端渲染│ ├── shared // 共享的工具库│ ├── vue // 主入口文件│ ├── vue-compat // 提供兼容Vue2的能力 接着，我执行了一下 npm install 发现报错了： 123456$ npm i&gt; @3.1.0-beta.4 preinstall /Users/vincent/Workspace/vue-next&gt; node ./scripts/checkYarn.jsThis repository requires Yarn 1.x for scripts to work properly. 看了下 scripts，原来是 preinstall 的时候执行了 checkYarn.js 这个脚本去判断包管理工具，所以我继续执行 yarn 安装依赖。然后执行 yarn dev 开发环境打包试了一下，编译结果放在 ./vue/dist/vue.global.js，但是没有生成 sourcemap，如果没有 sourcemap 后面就很不方便调试了。看了下打包脚本 dev.js，发现是有 sourcemap 参数的： ./scripts/dev.js12const sourceMap = args.sourcemap || args.s// ... 于是试了一下执行下面指令： 1$ npx node scripts/dev.js -s 发现成功生成 vue.global.js.map，于是我在项目根目录，新建了一个 html： 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt; &lt;p&gt;{{count}}&lt;/p&gt; &lt;/div&gt; &lt;script src=&quot;./packages/vue/dist/vue.global.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const vm = Vue.createApp({ data() { return { count: 0 } } }).mount('#app'); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 然后新建了 launch 脚本 (需要安装 Debugger for Chrome VSCode 插件)： ./.vscode/launch.json123456789101112{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Chrome Debug&quot;, &quot;file&quot;: &quot;index.html&quot;, &quot;webRoot&quot;: &quot;${workspaceFolder}&quot; } ]} 我在入口文件中第一个执行的函数 registerRuntimeCompiler 上下了个断点： ./packages/vue/src/index.ts12&gt; registerRuntimeCompiler(compileToFunction)// ... 然后执行调试 (F5)，可以捕获到断点，至此 Vue3 的源码调试环境搭建完成。 入口点分析首先从入口文件 ./packages/vue/src/index.ts 分析： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495import { initDev } from './dev'import { compile, CompilerOptions, CompilerError } from '@vue/compiler-dom'import { registerRuntimeCompiler, RenderFunction, warn } from '@vue/runtime-dom'import * as runtimeDom from '@vue/runtime-dom'import { isString, NOOP, generateCodeFrame, extend } from '@vue/shared'import { InternalRenderFunction } from 'packages/runtime-core/src/component'if (__DEV__) { initDev()}// 全局编译缓存const compileCache: Record&lt;string, RenderFunction&gt; = Object.create(null)function compileToFunction( template: string | HTMLElement, options?: CompilerOptions): RenderFunction { if (!isString(template)) { if (template.nodeType) { // 如果 template 是 HTMLElement，转为字符串 template = template.innerHTML } else { __DEV__ &amp;&amp; warn(`invalid template option: `, template) return NOOP } } const key = template const cached = compileCache[key] if (cached) { // 命中缓存 return cached } if (template[0] === '#') { // 如果 template 是 element id，查询 HTMLElement，后转为字符串 const el = document.querySelector(template) if (__DEV__ &amp;&amp; !el) { warn(`Template element not found or is empty: ${template}`) } // __UNSAFE__ // Reason: potential execution of JS expressions in in-DOM template. // The user must make sure the in-DOM template is trusted. If it's rendered // by the server, the template should not contain any user data. // 这里意思是说使用 element id 不安全，template 可能会执行不安全的 js template = el ? el.innerHTML : `` } // 调用 @vue/compiler-dom 的 compile 函数编译模板，返回结果是用于渲染 DOM 的源码 const { code } = compile( template, extend( { hoistStatic: true, onError: __DEV__ ? onError : undefined, onWarn: __DEV__ ? e =&gt; onError(e, true) : NOOP } as CompilerOptions, options ) ) function onError(err: CompilerError, asWarning = false) { const message = asWarning ? err.message : `Template compilation error: ${err.message}` const codeFrame = err.loc &amp;&amp; generateCodeFrame( template as string, err.loc.start.offset, err.loc.end.offset ) warn(codeFrame ? `${message}\\n${codeFrame}` : message) } // 把刚才 compiler 编译后的代码封装成函数，处理了全局 Vue 引入的情况 const render = (__GLOBAL__ ? new Function(code)() : new Function('Vue', code)(runtimeDom)) as RenderFunction // mark the function as runtime compiled ;(render as InternalRenderFunction)._rc = true // 缓存编译结果并输出 render 函数 return (compileCache[key] = render)}// 注册编译函数，跳进去能发先就是吧参数 compileToFunction 函数放到全局registerRuntimeCompiler(compileToFunction)export { compileToFunction as compile }// 暴露 runtime 方法，例如 createApp 等等export * from '@vue/runtime-dom' 入口点的逻辑很简单，就是封装 @vue/compiler-dom 的 compile 函数，处理模板，添加缓存，注册编译函数。 createApp当注册完编译函数后，紧接着就是调用 Vue.createApp 来创建 Vue 实例了，继续跟代码，在 @vue/runtime-dom 中找到 createApp 的定义。 ./packages/runtime-dom/src/index.ts1234567891011121314151617181920212223242526272829303132333435363738394041function ensureRenderer() { return renderer || (renderer = createRenderer&lt;Node, Element&gt;(rendererOptions))}export const createApp = ((...args) =&gt; { // 构建 app 实例，最终会 return 出去 const app = ensureRenderer().createApp(...args) if (__DEV__) { injectNativeTagCheck(app) injectCompilerOptionsCheck(app) } const { mount } = app // 重载 app.mount 方法 app.mount = (containerOrSelector: Element | ShadowRoot | string): any =&gt; { // 初始化容器 // 例如 app.mount('#app')，container const container = normalizeContainer(containerOrSelector) if (!container) return const component = app._component // 此处省略一些兼容性代码 // ... // 挂载前清空容器中的内容 container.innerHTML = '' // 调用 @vue/runtime-core 中的 mount 的方法得到一个 Proxy 对象 const proxy = mount(container, false, container instanceof SVGElement) if (container instanceof Element) { container.removeAttribute('v-cloak') container.setAttribute('data-v-app', '') } return proxy } return app}) as CreateAppFunction&lt;Element&gt; 代码中首先间接调用 @vue/runtime-core 里的 createRenderer 函数创建全局 renderer 实例，然后调用它的 createApp 方法创建 app 实例，而后对返回的 app 实例的 mount 方法进行二次封装，开发模式注入了两个函数，一些兼容 Vue2 的代码等，这些就不深入去看了，所以其实核心都在 core 包里。 ./packages/runtime-core/src/renderer.ts123456789101112131415161718export function createRenderer&lt; HostNode = RendererNode, HostElement = RendererElement&gt;(options: RendererOptions&lt;HostNode, HostElement&gt;) { return baseCreateRenderer&lt;HostNode, HostElement&gt;(options)}function baseCreateRenderer( options: RendererOptions, createHydrationFns?: typeof createHydrationFunctions): any { // 此处省略 2000 行代码 return { render, hydrate, createApp: createAppAPI(render, hydrate) }} 继续跟进 createRenderer，它会调用 baseCreateRenderer，然后返回三个方法： render hydrate createApp 其中 hydrate 主要跟服务端渲染相关，先跳过，而 createApp 是通过 createAppAPI 创建的，我们继续跟进去看看。 ./packages/runtime-core/apiCreateApp.ts1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859export interface App&lt;HostElement = any&gt; { version: string config: AppConfig use(plugin: Plugin, ...options: any[]): this mixin(mixin: ComponentOptions): this component(name: string): Component | undefined component(name: string, component: Component): this directive(name: string): Directive | undefined directive(name: string, directive: Directive): this mount( rootContainer: HostElement | string, isHydrate?: boolean, isSVG?: boolean ): ComponentPublicInstance unmount(): void provide&lt;T&gt;(key: InjectionKey&lt;T&gt; | string, value: T): this // internal, but we need to expose these for the server-renderer and devtools _uid: number _component: ConcreteComponent _props: Data | null _container: HostElement | null _context: AppContext /** * v2 compat only */ filter?(name: string): Function | undefined filter?(name: string, filter: Function): this /** * @internal v3 compat only */ _createRoot?(options: ComponentOptions): ComponentPublicInstance}export interface AppContext { app: App // for devtools config: AppConfig mixins: ComponentOptions[] components: Record&lt;string, Component&gt; directives: Record&lt;string, Directive&gt; provides: Record&lt;string | symbol, any&gt; /** * Flag for de-optimizing props normalization * @internal */ deopt?: boolean /** * HMR only * @internal */ reload?: () =&gt; void /** * v2 compat only * @internal */ filters?: Record&lt;string, Function&gt;} 基本上从 interface 就能猜出 app 实例有那些功能，首先它会创建一个上下文对象 context，比如我们 use components，mixin 等等就会挂载 app context 的实例上。 mount然后我们重点看一下 mount 函数，看一下 Vue3 的首次渲染都做了什么： ./packages/runtime-core/apiCreateApp.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051mount( rootContainer: HostElement, isHydrate?: boolean, isSVG?: boolean): any { if (!isMounted) { // 创建根节点 const vnode = createVNode( rootComponent as ConcreteComponent, rootProps ) // 把 app 的 context 存在根节点上 vnode.appContext = context // 热更新 if (__DEV__) { context.reload = () =&gt; { render(cloneVNode(vnode), rootContainer, isSVG) } } if (isHydrate &amp;&amp; hydrate) { // SSR 相关 hydrate(vnode as VNode&lt;Node, Element&gt;, rootContainer as any) } else { // 渲染根节点到根容器 render(vnode, rootContainer, isSVG) } // 挂载完成 isMounted = true // 跟容器挂在 app 实例对象上 app._container = rootContainer // for devtools and telemetry ;(rootContainer as any).__vue_app__ = app if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) { devtoolsInitApp(app, version) } return vnode.component!.proxy } else if (__DEV__) { warn( `App has already been mounted.\\n` + `If you want to remount the same app, move your app creation logic ` + `into a factory function and create fresh app instances for each ` + `mount - e.g. \\`const createMyApp = () =&gt; createApp(App)\\`` ) }} render上面 mount 中的调用的 render 函数，其实就是之前提到的 baseCreateRenderer 函数中返回的 render。 ./packages/runtime-core/src/renderer.ts123456789101112const render: RootRenderFunction = (vnode, container, isSVG) =&gt; { if (vnode == null) { if (container._vnode) { unmount(container._vnode, null, null, true) } } else { // 调用 patch 方法挂载 VNode 到 容器 patch(container._vnode || null, vnode, container, null, null, null, isSVG) } flushPostFlushCbs() container._vnode = vnode} 我们发现，render 其实调用的是 patch 函数，或者说这就是老生常谈的 diff，其实 baseRenderer 那两千多行的代码其实都是为了 patch 服务的。 ./packages/runtime-core/src/renderer.ts123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112const patch: PatchFn = ( n1, // oldNode，当旧节点为 null 时表现为 mount n2, // newNode container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = false) =&gt; { // patching &amp; not same type, unmount old tree if (n1 &amp;&amp; !isSameVNodeType(n1, n2)) { anchor = getNextHostNode(n1) unmount(n1, parentComponent, parentSuspense, true) n1 = null } if (n2.patchFlag === PatchFlags.BAIL) { optimized = false n2.dynamicChildren = null } const { type, ref, shapeFlag } = n2 switch (type) { case Text: processText(n1, n2, container, anchor) break case Comment: processCommentNode(n1, n2, container, anchor) break case Static: if (n1 == null) { mountStaticNode(n2, container, anchor, isSVG) } else if (__DEV__) { patchStaticNode(n1, n2, container, isSVG) } break case Fragment: processFragment( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) break default: if (shapeFlag &amp; ShapeFlags.ELEMENT) { processElement( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } else if (shapeFlag &amp; ShapeFlags.COMPONENT) { processComponent( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized ) } else if (shapeFlag &amp; ShapeFlags.TELEPORT) { ;(type as typeof TeleportImpl).process( n1 as TeleportVNode, n2 as TeleportVNode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals ) } else if (__FEATURE_SUSPENSE__ &amp;&amp; shapeFlag &amp; ShapeFlags.SUSPENSE) { ;(type as typeof SuspenseImpl).process( n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals ) } else if (__DEV__) { warn('Invalid VNode type:', type, `(${typeof type})`) } } // set ref if (ref != null &amp;&amp; parentComponent) { setRef(ref, n1 &amp;&amp; n1.ref, parentSuspense, n2 || n1, !n2) }} 跟踪代码得知，首次渲染，n1 旧节点为 null，n2 为待渲染的节点，所以 patch 表现为挂载节点，后面替换节点的时候依然靠的是这个 patch 方法。相比于 Vue2 的 full diff，Vue3 显得智能很多，原因在 Vue3 会根据节点的类型分别调用不同的 process 函数，然后根据节点不同的 patchFlags，调用对应的 patch 方法。 reactive响应式原理应该老生常谈了，Vue3 把响应式 API 单独抽出来一个 reactive 的包，并且改用 Proxy 作为它响应式的核心。记得之前写 Vue2 的时候最讨厌的就是碰到无法触发响应的数据要自己写一边 this.$set 方法，原因在于 defineProperty 对于类型支持的不完善，因此魔改了很多特殊数据类型的函数，比如 push、pop、slice 等，改成 Proxy 就舒服多了。下面我简单实现了一下 reactive 这个函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Reactive Demo&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script&gt; const data = reactive({ a: { b: { c: 0 }} }); setInterval(() =&gt; { data.a.b.c++ }, 100); function effectFn() { document.getElementById('app').innerHTML = data.a.b.c; } const targetMap = new Map(); function reactive(target) { return new Proxy(target, { get(target, key, receiver) { const ret = Reflect.get(target, key, receiver); track(target, key); if (typeof ret !== 'object') return ret return reactive(ret); }, set(target, key, receiver) { const ret = Reflect.set(target, key, receiver); trigger(target, key); return ret } }) } function track(target, key) { let depsMap = targetMap.get(target); if (!depsMap) { depsMap = new Map(); targetMap.set(target, depsMap); } let deps = depsMap.get(key); if (!deps) { deps = new Set(); depsMap.set(key, deps); } deps.add(effectFn) } function trigger(target, key) { const depsMap = targetMap.get(target); if (depsMap) { const deps = depsMap.get(key); if (deps) { deps.forEach(effect =&gt; effect()); } } } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2021/05/26/20210526_Vue3%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"}],"tags":[{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"},{"name":"WebGL","slug":"WebGL","link":"/tags/WebGL/"},{"name":"软路由","slug":"软路由","link":"/tags/%E8%BD%AF%E8%B7%AF%E7%94%B1/"},{"name":"OpenWrt","slug":"OpenWrt","link":"/tags/OpenWrt/"},{"name":"Javascript","slug":"Javascript","link":"/tags/Javascript/"},{"name":"TC39","slug":"TC39","link":"/tags/TC39/"},{"name":"Three.js","slug":"Three-js","link":"/tags/Three-js/"},{"name":"图形学","slug":"图形学","link":"/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"网络建设","slug":"网络建设","link":"/categories/%E7%BD%91%E7%BB%9C%E5%BB%BA%E8%AE%BE/"},{"name":"工具使用","slug":"工具使用","link":"/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"},{"name":"技术积累","slug":"技术积累","link":"/categories/%E6%8A%80%E6%9C%AF%E7%A7%AF%E7%B4%AF/"}]}